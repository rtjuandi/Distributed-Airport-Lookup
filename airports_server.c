/* Filename: aiports_server.c */
/* Authors: Christopher Fong, Raydi Tjuandi, Gavin Limchayseng */
/* Date: 10/17/20 */
/* Revised: 10/25/20 */

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "airports.h"
#include <fstream>
#include <string>
#include <bits/stdc++.h> 
#include <math.h>
#include <iostream>

#define pi 3.14159265358979323846 

using namespace std;

const int k = 2;        // k dimensions of tree
const int amt = 5;      // amount of nearest neighbors searched for

int pushes = 0;

//Node that will make a KD-Tree
struct Node 
{ 
    sAirport* data = nullptr;
    double point[k]; // To store k dimensional point 
    Node *left, *right; 
}; 

// A method to create a node of KD-tree 
struct Node* newNode(sAirport* newPort, double arr[]) 
{ 
    Node* temp = new Node;

    temp->data = newPort;

    for (int i=0; i<k; i++) 
    temp->point[i] = arr[i]; 

    temp->left = temp->right = nullptr; 
    return temp; 
} 

// A Linked List Node
struct LLNode
{
    sAirport* data;
    double dist;
    LLNode* next = nullptr;
};

// Inserts a new node and returns root of modified tree 
// The parameter depth is used to decide axis of comparison 
Node *insertRec(Node *root, sAirport* newPort, double point[], unsigned depth) 
{ 
	// Tree is empty? 
	if (root == NULL) 
		return newNode(newPort, point); 

	// Calculate current dimension (cd) of comparison 
	unsigned cd = depth % k; 

	// Compare the new point with root on current dimension 'cd' 
	// and decide the left or right subtree 
	if (point[cd] < (root->point[cd])) 
		root->left = insertRec(root->left, newPort, point, depth + 1); 
	else 
		root->right = insertRec(root->right, newPort, point, depth + 1); 

	return root; 
} 

//Inserts the node to the KD-Tree
Node* insert(Node *root, sAirport* newPort) 
{ 
    double point[] = {newPort->loc.longitude, newPort->loc.latitude};
	return insertRec(root, newPort, point, 0); 
} 

//Pushes an airport found in a node to a linked lists 
void push(LLNode* &head, Node* n, double d)
{
    LLNode* temp;
    if(head != nullptr)
    {
        if(d < head->dist)
        {
            LLNode* newLL = new LLNode;
            newLL->data = n->data;
            newLL->dist = d;
            newLL->next = head;
            head = newLL;
        }
        else
        {
            temp = head;
            bool inserted = false;
            while(temp->next != nullptr)
            {
                if(d < temp->next->dist)
                {
                    LLNode* newLL = new LLNode;
                    newLL->data = n->data;
                    newLL->dist = d;
                    newLL->next = temp->next;
                    temp->next = newLL;
                    inserted = true;
                    break;
                }
                temp = temp->next;
            }
            if(!inserted)
            {
                LLNode* newLL = new LLNode;
                newLL->data = n->data;
                newLL->dist = d;
                newLL->next = nullptr;
                temp->next = newLL;
            }
        }
    }
    else
    {
        head = new LLNode;
        head->data = n->data;
        head->dist = d;
        head->next = nullptr;
    }
    pushes++;
}

//finds the distance of the 5th airport
double lastDist(LLNode* root, int index)
{
    LLNode* temp = root;
    for(int i = 0; i < index; i++)
    {
        if(temp == nullptr)
            return -1;
        temp = temp->next;
    }
    return temp->dist;
}


//Distance Calculations
double deg2rad(double deg) 
{   
    return (deg * pi / 180); 
} 

double rad2deg(double rad) 
{   
    return (rad * 180 / pi); 
} 

double distance(double lat1, double lon1, double lat2, double lon2, char unit) 
{   
    double theta, dist;   
    theta = lon1 - lon2;   
    dist = sin(deg2rad(lat1)) * sin(deg2rad(lat2)) + cos(deg2rad(lat1)) *          
           cos(deg2rad(lat2)) * cos(deg2rad(theta));   
    dist = acos(dist);   
    dist = rad2deg(dist);   
    dist = dist * 60 * 1.1515;   
    switch(unit) 
    {     
        case 'M':       
            break;     
        case 'K':       
            dist = dist * 1.609344;       
            break;     
        case 'N':       
            dist = dist * 0.8684;       
            break;   
    }     
    return (dist); 
}

//Recursive search of the KD-Tree
void knnSearch(Node* curr, double coord[k], LLNode* &llist, int depth)
{
    if(curr == nullptr) 
        return;

    push(llist, curr, distance(curr->point[0], curr->point[1], coord[0], coord[1], 'M'));

    int d = depth % k;
    Node* otherNode = nullptr;

    if(coord[d] < curr->point[d])
    {
        knnSearch(curr->left, coord, llist, depth + 1);
        otherNode = curr->right;
    }
    else
    {
        knnSearch(curr->right, coord, llist, depth + 1);
        otherNode = curr->left;
    }

    double delta = fabs(curr->point[d] - coord[d]);
    if(pushes < amt || delta < lastDist(llist, amt))
    {
        knnSearch(otherNode, coord, llist, depth + 1);
    }
}

//Finds K nearest neighbors in the KD-Tree
LLNode* knn(Node* curr, double coord[2])
{
    LLNode* llist = nullptr;
    knnSearch(curr, coord, llist, 0);
    return llist;
}

//Root built outside of server so it doesnt have to
//repopulate every call
struct Node * root = nullptr;

airports_ret *
get_airports_1_svc(sLocation *argp, struct svc_req *rqstp)
{
	static airports_ret result;
    LLNode* target;

	//Loads KD-Tree with values read from .txt
	if(root == nullptr)
	{
		string fName = "airport-locations.txt";
		ifstream file (fName);
		string line;

		if(file.is_open())
		{
			getline(file, line);
			while(getline(file, line))
			{
				if(line != "")
				{
					//Parses the airport lists to get each individual value
					sAirport* temp = new sAirport;
					temp->code=(char *)malloc(60*sizeof(char));
					strcpy(temp->code, (line.substr(1,3)).c_str());

					int namestart = line.find('\t');
					
					temp->name=(char *)malloc(60*sizeof(char));
					strcpy(temp->name, (line.substr(namestart+1, line.length())).c_str());
					
					int ws[3] = {0};
					int iter = 0;
					int len = line.length();
					ws[0] = line.find(' ');
					line[ws[0]] = '~';
					ws[1] = line.find(' ');
					line[ws[1]] = '~';
					ws[2] = line.find(' ');

					temp->loc.latitude = stod(line.substr(ws[0]+1, ws[1] - ws[0]));
					temp->loc.longitude = stod(line.substr(ws[1]+1, ws[2] - ws[1]));

					root = insert(root, temp); 
				}
			}
		}
	}

    double input[2];
	input[0] = argp->longitude;
	input[1] = argp->latitude;

	//Creates a list of nearest neighbors
    target = knn(root, input);

	//Cuts down the amount of values in list to amt
	//Copies it into an array that can be sent back
	//to places server
    LLNode* parser = target;
    sAirportList* rtn = new sAirportList;
    rtn->ap = *parser->data;
    rtn->ap.distance = parser->dist;
    sAirportList* placer = rtn;
	parser = parser->next;
    for(int i = 1; i < amt; i++)
    {
        if(parser != nullptr)
        {
            sAirportList* newNode = new sAirportList;
            newNode->ap = *parser->data;
            newNode->ap.distance = parser->dist;
            placer->next = newNode;
            placer = placer->next;
			parser = parser->next;
        }
    }
	result.err = 0;
    result.airports_ret_u.sAL = rtn;
	return &result;
}
